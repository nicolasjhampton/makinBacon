{"version":3,"sources":["server.js","globalVar.js","routes.js","gameflow.js","emitters.js","dynamics.js","api.js","random.js","objectFunct.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"app.js","sourcesContent":["'use strict';\n\n/**********************************\n 1. express http/socket.io boilerplate\n **********************************/\n\n// Starting our http/socket.io server\nvar express = require('express'),\n    app = express(),\n    server = require('http').createServer(app),\n    io = require('socket.io')(server);\n\nvar request = require('request-promise');\n\n// Openshift adaptive enviornment variables\nvar server_port = process.env.PORT || 5000;\n\n// set port for our express instance\napp.set('port', server_port);\n\n// define public folder to serve static files\napp.use(express.static(__dirname + '/public'));\n\n// Set the sever to listen for get requests\nserver.listen(app.get('port'), function () {\n   console.log(\"Listening on port \" + app.get('port'));\n});\n/*   End of File  */","/************************\n 2. global variables\n ************************/\n\n// arrays of the actors and movies chosen (note: combined into stack)\nvar gameStack = [];\n\n// newGame will let us know that the game has already started\n// so we should come into the game in progress without resetting it\nvar newGame = true;\n\n// Each game started will get a gameNumber ID, which will\n// correspond with a socket route and it's storage position in the\n// stack of games\nvar gameNumber = 0;\n/*   End of File  */","/**************************************\n 3. Open socket routes: Main program here\n **************************************/\n\nio.sockets.on('connect', function(socket) {\n\n\n  socket.on('adduser', function(data){\n    // Clear any old game from the browser, happens when server is restarted to everyone\n    // for the first game, the starting actor is going to be null, thus the or pipe in createGameList\n    newPlayerInit(socket, data);\n\n  });\n\n  socket.on('select game', function(data){\n\n    console.log('selection received');\n\n    if(data.gameID === 'newGame') { //called by the first player in game\n\n      startNewGame(data, socket);\n\n    } else {\n\n      joinGameInProgress(data, socket);\n\n    }\n\n  }); // end of 'select game' socket\n\n  socket.on('update', function(data) {\n\n    console.log('new addition to the stack received ' + data.gameID);\n\n    addChoiceAndUpdateGame(data);\n\n  }); // end of 'update' socket\n\n  socket.on('leaveroom', function(data){\n\n    socket.leave(data.ID);\n\n  }); // end of 'leaveroom' socket\n\n}); // end of 'connect' socket\n/*   End of File  */","/*************************\n  4. Game Flow functions\n *************************/\n\n\nvar startNewGame = function (data, socket) {\n\n  // create game and attach needed info to data object\n  data['gameID'] = createGame(data.player);\n  data['type'] = \"actors\";\n  data['firstStackEmit'] = true;\n\n\n  // join a new private game room here\n  socket.join(data.gameID);\n\n  // Create request for a random page of popular actors\n  var getPopularPage = getApiOptions('popular', random(true));\n\n  // request promise chain\n  request(getPopularPage)\n    .then(JSON.parse)\n    .then(getRandomActor)\n    .then(request)\n    .then(JSON.parse)\n    .then(function(response){\n      return createFirstStackObject(response, data);\n    })\n    .then(sendStack);\n\n};\n\nvar joinGameInProgress = function(data, socket) {\n  // ... else move them to the appropriate socket for their selected game\n  socket.join(data.gameID);\n\n  if(!gameStack[data.gameID].playerList[data.player]) {\n    // Add player to the game\n    gameStack[data.gameID].playerList[data.player] = 0;\n  }\n\n  // then send them a new update of the current game in progress\n  sendStack(data);\n};\n\nvar addChoiceAndUpdateGame = function (data) {\n  // making the variable managable\n  var stack = gameStack[data.gameID].stack;\n\n  // Test to see if communication was too fast and we need to drop a update\n  if(data.type !== stack[stack.length - 1].type) {\n\n    // Set the options for the new api request\n    var options = getApiOptions(data.type, data.id);\n\n    request(options)\n      .then(JSON.parse)\n      .then(function(response){\n        return createStackObject(response, data);\n      })\n      .then(checkBacon)\n      .then(sendStack);\n\n  }\n};\n/*   End of File  */","/***********************\n 5. Emitters\n ***********************/\n\n/*\n * This communication function is ran when a new browser arrives\n * ToDo: create a database of players\n */\nvar newPlayerInit = function(socket, data) {\n\n  // stores the player name under the list of usernames active\n  socket.username = data.username;\n\n  socket.emit('init', {game:{} ,gameList:createGameList(), username:socket.username});\n\n  // Clear any old game in the browser, give username\n  //socket.emit('update', {game:{}, username:socket.username});\n\n  // create and emit a current list of games, then wait for selection\n  //socket.emit('gameList', {gameList:createGameList()});\n\n};\n\n\n/*\n * This is the function we'll use to emit to all players\n * it's built into getDBInfo at the end for timing reasons\n */\nvar sendStack = function(data) {\n\n  // Emit the game to it's assigned room\n  io.sockets.in(data.gameID).emit('update', {game:gameStack[data.gameID]});\n\n  // Update the gamelist for all players and rooms\n  io.sockets.emit('gameList', {gameList:createGameList()});\n\n  // remove this game if the game was won/lost\n  if(gameStack[data.gameID].actorCount === 7 || gameStack[data.gameID].isBacon === true) {\n    removeGame(data.gameID);\n  }\n\n};\n\n\nvar removeGame = function(ID) {\n\n gameStack[ID].stack = [{name:'Game Over'}];\n gameStack[ID].players = {deadGame:'Game Over'};\n gameStack[ID].isBacon = true;\n\n // Send out a roomwide leaveroom event, so that all sockets come back and\n // leave the room\n io.sockets.in(ID).emit('leaveroom');\n\n // Send revised game list\n io.sockets.emit('gameList', {gameList:createGameList()});\n\n};\n/*   End of File  */","/*************************\n 6. Game dynamics\n *************************/\n\nvar createFirstStackObject = function (jsonObject, data) {\n\n  addActorToStack(jsonObject, data);\n\n  return data;\n\n};\n\nvar createStackObject = function(jsonObject, data) {\n\n  // test part one: if we asked for an actor\n  if(data.type === \"actors\") {\n\n    addActorToStack(jsonObject, data, false);\n\n  // test part two: if we asked for a movie\n  } else if(data.type === \"movies\") { // This is a movie, and thus a game in progress\n\n    addMovieToStack(jsonObject, data);\n\n  } //end if(data.type is movies or actors)\n\n  return data;\n\n};\n\nvar addActorToStack = function(jsonObject, data) {\n\n  // If this is the first actor, points and credit go to no one\n  var newActorObject = createActorObject(jsonObject, data);\n\n  if(data.firstStackEmit !== true) { // If this is a new game\n\n    // Points rule ****\n    // add the 100 points to the score for that player\n    gameStack[data.gameID].playerList[data.player] += 100;\n\n  }\n\n  // Game rule ****\n  // Incrementing the actor count\n  gameStack[data.gameID].actorCount += 1;\n\n  // store this actor into the corresponding game in the gameStack\n  gameStack[data.gameID].stack.push(newActorObject);\n\n};\n\nvar addMovieToStack = function(jsonObject, data) {\n\n    // create the movie with complete actor credits info\n    var newMovieObject = createMovieObject(jsonObject, data);\n\n    // Points rule ****\n    // add the 100 points to the score for that player\n    gameStack[data.gameID].playerList[data.player] += 100;\n\n    // store this movie into the corresponding game in the gameStack\n    gameStack[data.gameID].stack.push(newMovieObject);\n\n};\n\n\nvar checkBacon = function (data) {\n\n  var ID = data.gameID;\n  var player = data.player;\n\n  // Variable to test the credits for bacon\n  var baconSearch = gameStack[ID].stack[gameStack[ID].stack.length - 1].credits;\n\n  //we're going to text if kevin bacon is in this movie\n  for(var actor = 0; actor < baconSearch.length; actor++) {\n\n    if(baconSearch[actor].id === 4724) {\n\n      // Increase the actor count\n      gameStack[ID].actorCount += 1;\n\n      // Add the extra Bacon points to the winner's score\n      gameStack[ID].playerList[player] += 100;\n\n      // Push the final bacon to the stack\n      gameStack[ID].stack.push(returnBacon(data));\n\n      // set the game to won\n      gameStack[ID].isBacon = true;\n\n      // break the loop\n      break;\n    }\n  }\n\n  return data;\n\n};\n\nvar returnBacon = function (data) {\n\n // Winning object of the game\n var kevinBacon = {\n   gameID: data.gameID,\n   player:data.player,\n   type: \"actors\",\n   name: \"Kevin Bacon\",\n   id: 4724,\n   poster: \"http://image.tmdb.org/t/p/w92/p1uCaOjxSC1xS5TgmD4uloAkbLd.jpg\",\n   credits: []\n };\n\n return kevinBacon;\n};\n/*   End of File  */","/************************\n 7. themoviedb api variables\n ************************/\n\n/*\n * All the variables for the movie database are factored out\n * and self-contained in this switch function, for easy update.\n */\nvar getApiOptions = function (optionsRequest, idOrPage) {\n\n  // our api key for api.themoviedb.org/3/\n  // Go get your own!\n  var apiKey = '';\n\n  // Beginning Url for all api requests, using version 3 of api\n  var apiUrl = 'https://api.themoviedb.org/3/';\n\n  // Beginning Url for all pictures from api\n  var posterUrl = 'http://image.tmdb.org/t/p/w92';\n\n  // If we get no image we'll send a generic question mark image from wikipedia\n  var unknownImg = 'https://upload.wikimedia.org/wikipedia/commons/4/44/Question_mark_(black_on_white).png';\n\n  switch(optionsRequest) {\n\n    case 'popular':\n       return {\n                url: apiUrl + 'person/popular?page=' + idOrPage + '&api_key=' + apiKey,\n                method: \"GET\"\n              };\n       break;\n\n    case 'actors':\n       return {\n                url: apiUrl + 'person/' + idOrPage + '?api_key=' + apiKey + '&append_to_response=movie_credits',\n                method: \"GET\"\n              };\n       break;\n\n    case 'movies':\n       return {\n                url: apiUrl + 'movie/' + idOrPage + '?api_key=' + apiKey + '&append_to_response=credits',\n                method: \"GET\"\n              };\n       break;\n\n    case 'poster':\n       if(idOrPage !== null) {\n\n         return posterUrl + idOrPage;\n\n       } else {\n\n         return unknownImg;\n\n       }\n       break;\n  }\n};\n/*   End of File  */","/***********************\n 8. randomizer functions\n ***********************/\n\n var random = function (type) {\n\n   if(type) {\n     // true is for page\n     return Math.floor((Math.random() * 100) + 1);\n   } else {\n     // false is for actor\n     return Math.floor((Math.random() * 20));\n   }\n\n };\n\n var getRandomActor = function (pageJSONObject) {\n\n   var chosenActor = pageJSONObject.results[random(false)];\n\n   return getApiOptions('actors', chosenActor.id);\n\n };\n /*   End of File  */","/*************************\n 9. Object functions\n *************************/\n\n /*\n  * This is the function we'll use to create a list of the\n  * current games for a player to join\n  */\nvar createGameList = function() {\n\n // create a list of games\n var gameList = gameStack.map(function(obj){\n   var game = {\n     gameID: obj.gameID,\n     playerList: obj.playerList,\n     starting: obj.stack[0].name || null\n   };\n   return game;\n });\n\n // return game list\n return gameList;\n\n};\n\n/*\n * This function will create the game object\n * Each player will have and id that corresponds to a\n * incrementing number property in the player object,\n * and the value of that property will be their score.\n * we're also going to start storing the stack inside this\n * object.\n */\nvar createGame = function (startingPlayer) {\n\n  // Create a new game w/ ID from the gameNumber index\n  var newGameID = gameNumber;\n\n  // increment the global gameNumber index\n  gameNumber++;\n\n  // Create an object that has usernames for each key and\n  // a score for each value\n  var players = {};\n  players[startingPlayer] = 0;\n\n  // create a new game object\n  var game = {\n    gameID: newGameID,\n    playerList:players,\n    actorCount: 0,\n    isBacon: false,\n    stack:[]\n  }\n\n  // We're going to put the game we create at it's location\n  // in the game stack that corresponds with it's gameID\n  gameStack[newGameID] = game;\n\n  return newGameID;\n\n};\n\n\n/*\n * These functions create the stack objects we'll emit back to the clients\n */\n\n// creates a movie stack object\nvar createMovieObject = function(jsonObject, data) {\n\n  // pull the movie data we need from the response\n  var movieTitle = jsonObject.original_title;\n  var movieID = jsonObject.id;\n\n  // We're creating the filepath for our poster here\n  // Note: See 'themoviedb api variables' section for contents\n  var moviePoster = getApiOptions('poster', jsonObject.poster_path);\n\n  // map a new array of cast members with only relevant details\n  var movieCast = jsonObject.credits.cast.map(function(obj){\n    var actor = {\n      type: \"actors\",\n      name: obj.name,\n      id: obj.id\n    };\n    return actor;\n  });\n\n  // make a singular reference for this movie\n  var newMovieObject = {\n    gameID: data.gameID,\n    player: data.player,\n    type: \"movies\",\n    name: movieTitle,\n    id: movieID,\n    poster: moviePoster,\n    credits: movieCast\n  };\n\n  // return created object\n  return newMovieObject;\n\n};\n\n// Creates an actor stack object\nvar createActorObject = function(jsonObject, data) {\n\n  // store details for the chosen actor\n  var actorName = jsonObject.name;\n  var actorID = jsonObject.id;\n\n  // We're creating the filepath for our poster here\n  // Note: See 'themoviedb api variables' section for contents\n\n  var actorPoster = getApiOptions('poster', jsonObject.profile_path);\n\n\n  // map a new array of movies actor has been in with only relevant details\n  var actorMovies = jsonObject.movie_credits.cast.map(function(obj){\n    var movie = {\n      type: \"movies\",\n      name: obj.original_title,\n      id: obj.id\n    };\n    return movie;\n  });\n\n  // make a singular reference object for this actor\n  var newActorObject = {\n    gameID: data.gameID,\n    player: data.firstStackEmit ? \"start\" : data.player,\n    type: \"actors\",\n    name: actorName,\n    id: actorID,\n    poster: actorPoster,\n    credits: actorMovies\n  };\n\n  // return created object\n  return newActorObject;\n\n};\n/*   End of File  */"],"sourceRoot":"/source/"}